# -*- coding: utf-8 -*-
"""RSAâ€“Cryptosystem.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1i8pN76LsqPUlcATZInSVEU3iplaTGXnB
"""

!apt install libmpc-dev

!pip install gmpy2

!pip install numpy

import gmpy2 as gmp
import numpy as np
import pandas as pd
import random

"""# Importing message"""

f = open("message.txt", "r")
message = f.read()
print(message)
f.close()

"""# Importing Vignere key"""

f = open("key.txt", "r")
key = f.read()
print(key)
f.close()

"""# Implementing vignere cipher encryption and decryption:"""

# Implementing vignere cipher encryption and decryption:

class VignereCipher:
    def vignereEncryption(self, message, vignereKey):
        vignereCipher = '' 
        l = len(vignereKey)
        for i in range(len(message)):
            vignereCipher = vignereCipher + chr((((ord(message[i])-97 + ord(vignereKey[i%l])-65)%26)+65))
        return vignereCipher
    
    
    def vignereDecryption(self, cipher, vignereKey):
        message = ''
        l = len(vignereKey)
        for i in range(len(cipher)):
            message = message + chr((((ord(cipher[i]) - 65 - ord(vignereKey[i%l])-65)%26) + 97))
        return message


vc = VignereCipher()
message = message.lower()
msg = ""
for i in range(len(message)):
    ch = message[i]
    ascii = ord(ch)-97
    if((ascii > -1 and ascii < 26) or (ascii > -50 and ascii <= -40)):
        msg = msg + ch
print("The message is: ", msg)

key = key.upper()
vignereCipher = vc.vignereEncryption(msg, key)

f = open("encryptedVignere.txt", "w")
f.write(vignereCipher)
f.close()

"""# Generating public and private keys"""

# Generating public and private keys:

class CA:

    range1 = 100074676
    range2 = 700089677
    p = 0
    q = 0
    n = 0

    # Finding the values of p and q as strong primes

    def chooseRandomVal(self):
        a = random.randint(self.range1, self.range2)
        if(gmp.is_strong_prp(a, 10)):
            return a
        else:
            return self.chooseRandomVal()


    # Finding the value of random number e:

    def randomSelect(self, givenRange):
        e = random.randint(1, givenRange)
        rem = gmp.gcd(e, givenRange)
        if(rem == 1): return e
        else: return self.randomSelect(givenRange)


    # Finding the value of secret key (d):

    def multiplicative_inverse(self, e, phi):
        r1 = phi
        r2 = e
        t1 = 0
        t2 = 1

        while r2 > 0:
            q = r1//r2
            r = r1 % r2
            r1 = r2
            r2 = r

            t = t1 - q*t2
            t1 = t2
            t2 = t

        if r1 == 1:
            return t1%phi

"""# Generating public and private key of CA:"""

ca = CA()
p = ca.chooseRandomVal()
q = ca.chooseRandomVal()
# print(p)
# print(q)
n = p*q
phi = (p-1)*(q-1)
pkCA = ca.randomSelect(phi)
print(pkCA)
skCA = ca.multiplicative_inverse(pkCA, phi)
print(skCA)
print("The value of n is: ", n)

"""# Generating public key of A and secret key of B using CA:"""

ca = CA()

pka = ca.randomSelect(phi)
print(n)
print("public key of A is: ", pka)
skb = ca.multiplicative_inverse(pka, phi)
print("secret key of B is: ", skb)

"""# Generating public key of B and secret key of A using CA:"""

ca = CA()

pkb = ca.randomSelect(phi)
print(n)
print("public key of B is: ", pkb)
ska = ca.multiplicative_inverse(pkb, phi)
print("secret key of A is: ", ska)

"""# Signing of keys by CA:"""

dig_pka = gmp.powmod(pka, skCA, n)
dig_ska = gmp.powmod(ska, skCA, n)

f = open("digKey_A.txt", "w")
f.write(str(dig_pka))
f.write(" ")
f.write(str(dig_ska))
f.write(" ")
f.close()

dig_pkb = gmp.powmod(pkb, skCA, n)
dig_skb = gmp.powmod(skb, skCA, n)

f = open("digKey_B.txt", "w")
f.write(str(dig_pkb))
f.write(" ")
f.write(str(dig_skb))
f.write(" ")
f.close()

"""# Sending this digitally signed files to A and B:

# Extracting the signed keys from files:
"""

def extractKys(filename):
    f = open(filename , "r")
    kys = f.read()
    p = 0
    arr = []
    pk = ""
    sk = ""
    while(kys[p] != " "):
        pk += kys[p]
        p = p+1
    p = p+1
    while(kys[p] != " "):
        sk += kys[p]
        p = p+1
    arr.append(pk)
    arr.append(sk)
    return arr
  

keyA = extractKys("digKey_A.txt")
d_pka = int(keyA[0])
d_ska = int(keyA[1])

keyB = extractKys("digKey_B.txt")
d_pkb = int(keyB[0])
d_skb = int(keyB[1])

"""# After receiving both A and B generate their original public and private keys using public key of CA:"""

pka = gmp.powmod(d_pka, pkCA, n)
ska = gmp.powmod(d_ska, pkCA, n)

pkb = gmp.powmod(d_pkb, pkCA, n)
skb = gmp.powmod(d_skb, pkCA, n)

"""# Implementing RSA encryption and decryption:"""

class RSA:
    n

    def RSAEncryption(self, e, new_app, blockSize):
        p = 0
        messagen = ""
        app = []
        while(p < len(new_app)):
            cphr = 0
            s = new_app[p]
            for j in range (len(s)):
                cphr = cphr + ((ord(s[j])-65) * np.power(26, j))
            p = p+1
            msg = gmp.powmod(int(cphr), int(e), int(n))

            arr = []
            self.decimalToBase(msg, 26, arr)
            char = ''
            for i in range (len(arr)):
                char = char + chr(arr[i]+65)

            app.append(char)     
            messagen += char

        print(messagen)
        return app


    def RSADecryption(self, d, app, blockSize):
        p = 0
        new_message = ""
        new_app = []
        while(p < len(app)):
            cphr = 0
            s = app[p]
            for j in range(len(s)):
                cphr = cphr + (ord(s[j])-65) * np.power(26, j)
            p = p+1
            new_msg = gmp.powmod(int(cphr), int(d), int(n))
            arr = []
            self.decimalToBase(new_msg, 26, arr) 
            char = ''
            for i in range (len(arr)):
                char = char + chr(arr[i]+65)

            new_app.append(char)
            new_message += char

        print(new_message)
        return new_app


    def decimalToBase(self, num, base, arr):
        if(num < base):
            arr.append(num) 
            return arr
        else:
            arr.append(num % base)
            return self.decimalToBase(num//base, base, arr)

# print(vignereCipher)
# print(key)

Cs = []
vc = vignereCipher.upper()
for i in range(len(vc)):
    Cs.append(str(vc[i]))

K = []
for i in range(len(key)):
    K.append(str(key[i]))


# Instantiating the object for decryption
rsa = RSA()  

# Decrypting both vignereCipher and key on senders side using secret key of A (ska):

decryptedCs = rsa.RSADecryption(ska, Cs, 4)
decryptedK = rsa.RSADecryption(ska, K, 4)
# print("The decrypted cipher text is: ", decryptedCs)
# print("The decrypted key is: ", decryptedK)

# Writing both cipher and key in seperate files

f1 = open("encryptedRSA.txt", "a")
f2 = open("encryptedKey.txt", "a")

for i in range(len(decryptedCs)):
    f1.write(decryptedCs[i])
f1.close()

for i in range(len(decryptedK)):
    f2.write(decryptedK[i])
f2.close()

# Encrypting decryptedCs and decryptedK on senders side using public key of B (pkb):

C = rsa.RSAEncryption(pkb, decryptedCs, 4)
K_dash = rsa.RSAEncryption(pkb, decryptedK, 4)
# print("The encrypted cipher is: ", C)
# print("The encrypted key is: ", K_dash)

# Decrypting the C and K_dash on receiver side using secret key of B (skb):

decryptedC = rsa.RSADecryption(skb, C, 4)
decryptedK_dash = rsa.RSADecryption(skb, K_dash, 4)
# print("The decrypted C  is: ", decryptedC)
# print("The decrypted K_dash  is: ", decryptedK_dash)

# Encrypting the decrypted values on receivers side using public key of A (pka):

new_Cs = rsa.RSAEncryption(pka, decryptedC, 4)
new_Key = rsa.RSAEncryption(pka, decryptedK_dash, 4)
# print("The encrypted new cipher is: ", new_Cs)
# print("The encrypted new key cipher is: ", new_Key)

vigCip = ""
vigKey = ""
for i in range(len(new_Cs)):
    vigCip = vigCip + new_Cs[i]

for i in range(len(new_Key)):
    vigKey = vigKey + new_Key[i]

vc = VignereCipher()
original = vc.vignereDecryption(vigCip, vigKey)
print(original)
f = open("decrypted.txt", "w")
f.write(original)
f.close()